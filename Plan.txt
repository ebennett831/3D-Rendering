🛠️ 3D Software Renderer Phases
Here's a structured list of each major phase, with details and goals.

✅ Phase 1: Drawing Surface + Game Loop (done)
Create a custom render loop and framebuffer where you manually write pixels.
BufferedImage as your pixel canvas


Game/render loop that updates every frame


Manual pixel manipulation via setRGB()


You now have: your own working software framebuffer



🔢 Phase 2: 3D Math Library (Vectors, Matrices)
Implement basic 3D math classes so you can represent and transform 3D geometry.
You’ll need:
Vector3 class (x, y, z, plus dot/cross product)


Matrix4x4 class (4×4 for transformations)


Matrix multiplication: model * view * projection


Optional: Vector4, Quaternion, Transform


✅ Goal: You can represent 3D points and transform them using matrices.

🔺 Phase 3: 3D Geometry + Projection
Define triangles in 3D space, transform them with matrices, and project them into 2D screen coordinates.
Core steps:
Define a 3D mesh (e.g. cube or triangle)


Build a projection matrix (e.g. perspective)


Transform 3D vertices to 2D


Map to screen space: center + scale


✅ Goal: You see a projected 3D shape drawn using 2D triangle outlines or points.

🎨 Phase 4: Triangle Rasterization + Z-Buffer
Draw filled triangles and handle overlapping geometry using depth testing.
You’ll implement:
Triangle rasterization (using barycentric coordinates or scanline)


Z-buffer (a 2D float array tracking depth per pixel)


Simple triangle fill and visibility check


✅ Goal: You can fill in 3D triangles on screen and draw them in the correct order.

💡 Phase 5: Basic Lighting (Phong or Lambertian)
Add lighting to give your 3D shapes depth and realism.
Includes:
Surface normals


Light direction


Basic diffuse (Lambert) or Phong (specular) lighting


Per-triangle or per-pixel shading


✅ Goal: Lighting affects brightness based on angle to light source.

🎥 Phase 6: Camera System + Scene Management
Implement a 3D camera so you can move around the scene.
View matrix (lookAt-style camera)


Mouse/keyboard input for camera control


Scene graph (optional)


✅ Goal: You can move the camera around and view objects from different angles.

🔁 Phase 7: Animation + Input
Add interactivity — rotate objects, move them, or respond to user input.
Object animation (rotate, scale, translate)


Time-based movement (delta time)


Keyboard/mouse input (Java AWT or Swing events)


✅ Goal: You have real-time animation or interactive control.

🧰 Bonus Phases (Advanced)
Phase
Description
Texturing
Map 2D images onto triangles
Back-face culling
Skip triangles facing away from the camera
Perspective-correct interp
Fix texture distortion
Shadow mapping
Advanced lighting
Software shaders
Emulate pixel/fragment shaders
OBJ/GLTF loading
Load real 3D models